"use strict";THREE.DRACOExporter=function(){},THREE.DRACOExporter.prototype={constructor:THREE.DRACOExporter,parse:function(geometry,options){if(void 0===DracoEncoderModule)throw new Error("THREE.DRACOExporter: required the draco_decoder to work.");void 0===options&&(options={decodeSpeed:5,encodeSpeed:5,encoderMethod:THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1});var dracoEncoder=DracoEncoderModule(),encoder=new dracoEncoder.Encoder,builder=new dracoEncoder.MeshBuilder,mesh=new dracoEncoder.Mesh;if(!0===geometry.isGeometry){var bufferGeometry=new THREE.BufferGeometry;bufferGeometry.fromGeometry(geometry),geometry=bufferGeometry}if(!0!==geometry.isBufferGeometry)throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.Geometry or THREE.BufferGeometry instance.");var vertices=geometry.getAttribute("position");if(builder.AddFloatAttributeToMesh(mesh,dracoEncoder.POSITION,vertices.count,vertices.itemSize,vertices.array),null!==(faces=geometry.getIndex()))builder.AddFacesToMesh(mesh,faces.count/3,faces.array);else{for(var faces=new(65535<vertices.count?Uint32Array:Uint16Array)(vertices.count),i=0;i<faces.length;i++)faces[i]=i;builder.AddFacesToMesh(mesh,vertices.count,faces)}if(!0===options.exportNormals){var normals=geometry.getAttribute("normal");void 0!==normals&&builder.AddFloatAttributeToMesh(mesh,dracoEncoder.NORMAL,normals.count,normals.itemSize,normals.array)}if(!0===options.exportUvs){var uvs=geometry.getAttribute("uv");void 0!==uvs&&builder.AddFloatAttributeToMesh(mesh,dracoEncoder.TEX_COORD,uvs.count,uvs.itemSize,uvs.array)}if(!0===options.exportColor){var colors=geometry.getAttribute("color");void 0!==colors&&builder.AddFloatAttributeToMesh(mesh,dracoEncoder.COLOR,colors.count,colors.itemSize,colors.array)}var encodedData=new dracoEncoder.DracoInt8Array;if(encoder.SetSpeedOptions(options.encodeSpeed||5,options.decodeSpeed||5),void 0!==options.encoderMethod&&encoder.SetEncodingMethod(options.encoderMethod),void 0!==options.quantization)for(i=0;i<5;i++)void 0!==options.quantization[i]&&encoder.SetAttributeQuantization(i,options.quantization[i]);var length=encoder.EncodeMeshToDracoBuffer(mesh,encodedData);if(dracoEncoder.destroy(mesh),0===length)throw new Error("THREE.DRACOExporter: Draco encoding failed.");var outputData=new Int8Array(new ArrayBuffer(length));for(i=0;i<length;i++)outputData[i]=encodedData.GetValue(i);return dracoEncoder.destroy(encodedData),dracoEncoder.destroy(encoder),dracoEncoder.destroy(builder),outputData}},THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING=1,THREE.DRACOExporter.MESH_SEQUENTIAL_ENCODING=0,THREE.DRACOExporter.POINT_CLOUD=0,THREE.DRACOExporter.TRIANGULAR_MESH=1,THREE.DRACOExporter.INVALID=-1,THREE.DRACOExporter.POSITION=0,THREE.DRACOExporter.NORMAL=1,THREE.DRACOExporter.COLOR=2,THREE.DRACOExporter.TEX_COORD=3,THREE.DRACOExporter.GENERIC=4;